//`define SIMULATE
`define Cart2K
`define Cart4K
`define Cart8K

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module myAtari(

	//////////// CLOCK ////////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
	
	//////////// JOYSTICK GPIO /////////////
	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		JOYSTICK_GPIO
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

`ifdef SIMULATE

// clock 27Mhz	
assign CLOCK_27 = ADC_CLK_10;	
assign ATARI_ROM_CS = 1'h1;

	MySystemSim sim( MAX10_CLK1_50, 			// 50 Mhz clock input
						CLOCK_27, 					// 27 Mhz clock input
						RES_n, 						// Active low reset input
						ATARI_CLOCKBUS16, 		// Atari 1.19 Mhz clock input
						ATARI_CLOCKPIXEL16, 	// Atari 3.58 Mhz clock input
						ATARI_ROM_CS, 			// ROM chip select output
						ATARI_ROM_Addr, 			// ROM address output
						ATARI_ROM_Dout); 		// ROM data input

`else

	//reg  ATARI_CLOCKBUS;
	wire ATARI_CLOCKPIXEL, ATARI_CLOCKBUS;
	
	wire [7:0] ATARI_COLOROUT;
	wire ATARI_ROM_CS;
	wire [11:0] ATARI_ROM_Addr;
	wire [7:0] ATARI_ROM_Dout, ATARI_ROM_Dout_4k_a, ATARI_ROM_Dout_4k_b, ATARI_ROM_Dout_4k_c, ATARI_ROM_Dout_4k_d;
	wire [7:0] ATARI_ROM_Dout_8k, ATARI_ROM_Dout_4k_e, ATARI_ROM_Dout_4k_f, ATARI_ROM_Dout_4k_g, ATARI_ROM_Dout_2k;
	wire ATARI_HSYNC, ATARI_HBLANK, ATARI_VSYNC, ATARI_VBLANK;
	wire ATARI_SW_COLOR, ATARI_SW_SELECT, ATARI_SW_START;
	wire [1:0] ATARI_SW_DIFF;
	wire [4:0] ATARI_JOY_A_in, ATARI_JOY_B_in;
	wire RES_n;
	wire ATARI_CLOCKPIXEL16, ATARI_CLOCKBUS16;
	wire DLY_RST;
	wire rw_n;
	
	
	reg [15:0] addr_reg_biL, addr_reg_biH; 	// Memory address register for built-in SRAM
	// SRAM registers and controls
	reg [17:0] addr_reg; // Memory address register for SRAM
	reg [7:0]  data_reg, data_regL, data_regH; // Memory data (register) wire for SRAM
	wire[7:0]  data_out, data_outL, data_outH; // for built-in SRAM test
	reg weL, weH, ramLowEn; 						 // Write enable for Low or High SRAM

	//Clock generation modules
	AtariClockGenerator2 atariclk (
					.areset(~DLY_RST),
					.inclk0(MAX10_CLK1_50),
					.c0(ATARI_CLOCKPIXEL16),
					.c1(ATARI_CLOCKBUS16),
					.locked(LEDR[9]));

					
	// I changed it to this because it seems the TIA needs the clocks running
	// during RESET...
	//
	reg [3:0] cnt = 0;
	reg		 reset_dividers;
	
	always @ (posedge ATARI_CLOCKBUS16 or negedge RES_n)
	begin
		if( ~RES_n)
		begin
			if( cnt == 4) reset_dividers <= 1;
			else begin
				reset_dividers <= 0;
				cnt <= cnt + 4'd1;
			end
		end
		else
			cnt <= 4'h00;
	end					
					
	ClockDiv16 clk16_1( .inclk(ATARI_CLOCKPIXEL16),
					.outclk(ATARI_CLOCKPIXEL),					// 3.58MHz
					.reset_n(/*RES_n*/reset_dividers));

/*					
	// clock generator 3 X CLOCK PIXEL (x16)
	reg[7:0] clk_3_count;
	
	always @ (posedge ATARI_CLOCKPIXEL16 or negedge reset_dividers)
	begin
		if( ~reset_dividers)
		begin
			clk_3_count <= 0;
			ATARI_CLOCKBUS <= 1;
		end
		else begin
			if (clk_3_count >= 24) begin
				 ATARI_CLOCKBUS <= ~ATARI_CLOCKBUS;
				 clk_3_count <= 0;
			 end else begin
				 clk_3_count <= clk_3_count + 8'h01;
			 end
		end
	end // always
*/
					
	ClockDiv16 clk16_2( .inclk(ATARI_CLOCKBUS16),
					.outclk(ATARI_CLOCKBUS),					// 1.19MHz
					.reset_n(reset_dividers));


	// =-=-=-=-=-=- M A I N   M O D U L E =-=-=-=-=-=- 
	Atari2600 atari2600(  .CLOCKPIXEL(ATARI_CLOCKPIXEL), .CLOCKBUS(ATARI_CLOCKBUS),
					.COLOROUT(ATARI_COLOROUT), .ROM_CS(ATARI_ROM_CS),
					.ROM_Addr(ATARI_ROM_Addr), .ROM_Dout(ATARI_ROM_Dout), .ROM_RW_n(rw_n),
					.HSYNC(ATARI_HSYNC), .HBLANK(ATARI_HBLANK), .VSYNC(ATARI_VSYNC),
					.VBLANK(ATARI_VBLANK), .RES_n(RES_n), .SW_COLOR(ATARI_SW_COLOR),
					.SW_DIFF(ATARI_SW_DIFF), .SW_SELECT(ATARI_SW_SELECT),
					.SW_START(ATARI_SW_START), .JOY_A_in(ATARI_JOY_A_in),
					.JOY_B_in(ATARI_JOY_B_in), .Leds( LEDR[7:0] ), .HEX4(HEX4), .HEX5(HEX5));					
					
`ifdef Cart2K

	// Cartridge module
	Cartridge2k cart2k
		//#(.romFile("cartridge.hex"))
		(.address(ATARI_ROM_Addr[10:0]),
		.clken(ATARI_ROM_CS),
		.clock(/*ATARI_CLOCKBUS*/MAX10_CLK1_50),
		.q(ATARI_ROM_Dout_2k));
		
	defparam cart2k.init_file = "./tools/kaboom.hex";
		
		
		
`endif
		
`ifdef Cart8K

	reg rom_switch;
	
	always @ ( negedge ATARI_CLOCKBUS/*ATARI_ROM_Addr*/ /*negedge rw_n or negedge RES_n*/)
	begin
		if( ~RES_n)
			rom_switch <= 1;
		else if( ATARI_ROM_CS /*&& ~rw_n*/)  // 28-02-17 should work not only wity STA but also with BIT $FFF9/8.... so not only write is allowed here
		begin
			if( rom_switch == 0 && ATARI_ROM_Addr == 12'hFF9)
				rom_switch <= 1;
			else if( rom_switch == 1 && ATARI_ROM_Addr == 12'hFF8)
				rom_switch <= 0;
				/*
			else 
				rom_switch = rom_switch;
				*/
		end
	end // always

	
	Cartridge8k cart8k
	(.address( { rom_switch, ATARI_ROM_Addr[11:0] } ),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_8k));
	
	//defparam cart8k.init_file = "./tools/mspacman.hex";
	defparam cart8k.init_file = "./tools/asteroid.hex";

`endif

`ifdef Cart4K
		
// Uncomment this block to use 4k cartridges
	Cartridge4k cart4k_a
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_a));
	defparam cart4k_a.init_file = "./tools/spcinvad.hex";


// Uncomment this block to use 4k cartridges
	Cartridge4k cart4k_b
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_b));
	defparam cart4k_b.init_file = "./tools/spachase.hex";
	
	Cartridge4k cart4k_c
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_c));
	defparam cart4k_c.init_file = "./tools/pacman.hex";
	
	
	Cartridge4k cart4k_d
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_d));
	defparam cart4k_d.init_file = "./tools/grandprx.hex";
	//defparam cart4k_d.init_file = "./tools/gptest99.hex";
	

	Cartridge4k cart4k_e
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_e));
	defparam cart4k_e.init_file = "./tools/jawbreak.hex";
	
	Cartridge4k cart4k_f
	(.address(ATARI_ROM_Addr),
	.clken(ATARI_ROM_CS),
	.clock(MAX10_CLK1_50),
	.q(ATARI_ROM_Dout_4k_f));
	//defparam cart4k_f.init_file = "./tools/hangman.hex";
	defparam cart4k_f.init_file = "./tools/berzerk.hex";

	
	
`endif
	//
	// NS 23-02-17 >>> using multiple cartridges resident in memory
	reg [2:0] r_SW9;
   assign ATARI_ROM_Dout = (r_SW9 == 3'd1) ? ATARI_ROM_Dout_4k_a : 
									 (r_SW9 == 3'd2) ? ATARI_ROM_Dout_4k_b : 
									  (r_SW9 == 3'd3) ? ATARI_ROM_Dout_4k_c :
									   (r_SW9 == 3'd4) ? ATARI_ROM_Dout_4k_d : 
									    (r_SW9 == 3'd5) ? ATARI_ROM_Dout_4k_e : 
									     (r_SW9 == 3'd6) ? ATARI_ROM_Dout_4k_f : 
									      (r_SW9 == 3'd7) ? ATARI_ROM_Dout_2k : 
											  ATARI_ROM_Dout_8k;

   // everytime a reset occurs, reread SW[9]
	always @ (negedge RES_n)
	begin
		r_SW9 <= SW[9:7];
	end

					
	// NEW 64K * 8 bits LOW order SRAM
	SRAM sramL( .address(addr_reg_biL),
					.clock(VGA_CTRL_CLK),
					.data(data_regL),
					.wren(~weL),
					.q(data_outL),
					.clken(ramLowEn));
					
	// NEW 64K * 8 bits High order SRAM
	SRAM sramH( .address(addr_reg_biH),
					.clock(VGA_CTRL_CLK),
					.data(data_regH),
					.wren(~weH),
					.q(data_outH),
					.clken(~ramLowEn));
					
	// Peripherals
	assign RES_n = DLY_RST;
	assign ATARI_SW_COLOR = 1; //SW[0];
	assign ATARI_SW_SELECT = KEY[0];
	assign ATARI_SW_START  = KEY[1];
	assign ATARI_SW_DIFF   = SW[6:5];
	assign ATARI_JOY_B_in  = JOYSTICK_GPIO[4:0]; //~SW[4:0];
	assign ATARI_JOY_A_in  = ~SW[4:0];

	// NTSC to VGA converter
	// Circular pixel buffers to temporarily store pixel data when the
	// VGA controller has control of the SRAM
	reg [7:0] pixelColor[511:0];
	reg [8:0] pixelX[511:0], pixelY[511:0];
	reg [8:0] curWriteIndex, curReadIndex;
	// NTSC Emulator
	reg [7:0] ATARI_Video_PixelX;
	reg [8:0] ATARI_Video_PixelY;
	reg R_ATARI_HBLANK;
	reg [7:0] R_ATARI_COLOROUT;

	assign LEDR[8] = ATARI_VBLANK;
	
	///////////////////////////////////
	// NTSC SYSTEM
	always @ (/*negedge*/posedge ATARI_CLOCKPIXEL)
	begin
		// Registered signals
		R_ATARI_HBLANK <= ATARI_HBLANK;
		R_ATARI_COLOROUT <= ATARI_COLOROUT;
		if (~RES_n)
		begin
			ATARI_Video_PixelX <= 8'd0;
			ATARI_Video_PixelY <= 9'd0;
			curWriteIndex <= 9'd0;
		end
		else begin
			// Use the end of the horizontal blanking signal to find the end of the
			// scanline.
			if( ATARI_HBLANK)
			begin
				ATARI_Video_PixelX <= 8'd0;
				// At the end of a scanline, move down one scanline
				if( ~R_ATARI_HBLANK & ~ATARI_VBLANK)
					ATARI_Video_PixelY <= ATARI_Video_PixelY + 9'd1;
			end
			// If we are not blanking, go to the next pixel in the scanline.
			else ATARI_Video_PixelX <= ATARI_Video_PixelX + 8'd1;
				
			// Use the vertical blanking signal to find the end of the frame.
			if (ATARI_VBLANK)
				ATARI_Video_PixelY <= 9'd0;
				
			// Write the pixel location and color to the circular buffer
			pixelColor[curWriteIndex] <= R_ATARI_COLOROUT;					// NS TESTED WITHOUT THE R_ 14-02-17
			pixelX[curWriteIndex] <= {1'b0, ATARI_Video_PixelX};
			pixelY[curWriteIndex] <= ATARI_Video_PixelY;
			curWriteIndex <= curWriteIndex + 9'd1;
		end
	end
		//
		// VGA Controller
		//wire VGA_CTRL_CLK;
		wire AUD_CTRL_CLK;
		wire [3:0] mVGA_R;	// was 9:0
		wire [3:0] mVGA_G;	// was 9:0
		wire [3:0] mVGA_B;	// was 9:0
		wire [19:0] mVGA_ADDR;
		wire [9:0] Coord_X, Coord_Y;
		
		Reset_Delay reset0 (
						.iCLK(MAX10_CLK1_50),
						.oRESET(DLY_RST), 
						.iRESET(KEY[0] | KEY[1]) );				// !!!!! DONT HAVE KEY[3] ?????????
						
		VGA_Audio_PLL vapll (
						.areset(~DLY_RST),
						.inclk0(MAX10_CLK1_50),
						.c0(VGA_CTRL_CLK),
						.c1(AUD_CTRL_CLK),
						.c2(VGA_CLK) );
						
		VGA_Controller u1 ( // Host Side
						.iCursor_RGB_EN(4'b0111),
						.oAddress(mVGA_ADDR),
						.oCoord_X(Coord_X),
						.oCoord_Y(Coord_Y),
						.iRed(mVGA_R),
						.iGreen(mVGA_G),
						.iBlue(mVGA_B),
						// VGA Side
						.oVGA_R(VGA_R),
						.oVGA_G(VGA_G),
						.oVGA_B(VGA_B),
						.oVGA_H_SYNC(VGA_HS),
						.oVGA_V_SYNC(VGA_VS),
						.oVGA_SYNC(VGA_SYNC),
						.oVGA_BLANK(VGA_BLANK),
						// Control Signal
						.iCLK(VGA_CTRL_CLK),
						.iRST_N(DLY_RST) );

	/* using DRAM here
	assign SRAM_ADDR = addr_reg;
	assign SRAM_DQ = (we)? 16'hzzzz : data_reg ;
	assign SRAM_UB_N = 0; // hi byte select enabled
	assign SRAM_LB_N = 0; // lo byte select enabled
	assign SRAM_CE_N = 0; // chip is enabled
	assign SRAM_WE_N = we; // write when ZERO
	assign SRAM_OE_N = 0; //output enable is overidden by WE
	*/
	wire [7:0] data_reg_w;
	assign data_reg_w = (ramLowEn)? data_outL : data_outH;


	// Connect the color table to the SRAM
	wire CT_clk;
	wire [3:0] CT_lum;
	wire [3:0] CT_hue;
	wire [1:0] CT_mode;
	wire [23:0] CT_outColor;
	
	TIAColorTable colort(
						.clk(CT_clk), 
						.lum(CT_lum), 
						.hue(CT_hue), 
						.mode(CT_mode),
						.outColor(CT_outColor));
						
	assign CT_clk = ~VGA_CTRL_CLK;
	assign CT_lum = data_reg_w[3:0]; //SRAM_DQ[3:0];
	assign CT_hue = data_reg_w[7:4]; //SRAM_DQ[7:4];
	assign CT_mode = 2'b00;

	// Show the color table output on the VGA
	/*
	assign mVGA_R = { CT_outColor[23:16], { 2{ CT_outColor[23:16] != 2'b0 } } } ;
	assign mVGA_G = { CT_outColor[15:8],  { 2{ CT_outColor[15:8] != 2'b0 } } } ;
	assign mVGA_B = { CT_outColor[7:0],   { 2{ CT_outColor[7:0] != 2'b0 } } } ;
	*/
	/* TESTING COLORS 4 bit NS 23-02-17 */
	/*
	assign mVGA_R = { CT_outColor[23:20], { 2{ CT_outColor[23:20] != 2'b0 } } } ;
	assign mVGA_G = { CT_outColor[15:12],  { 2{ CT_outColor[15:12] != 2'b0 } } } ;
	assign mVGA_B = { CT_outColor[7:4],   { 2{ CT_outColor[7:4] != 2'b0 } } } ;
	*/
	assign mVGA_R = { CT_outColor[23:20] };
	assign mVGA_G = { CT_outColor[15:12] };
	assign mVGA_B = { CT_outColor[7:4]   };

	// State machine to synchronize accesses to the SRAM
	wire syncing;
	assign syncing = (~VGA_VS | ~VGA_HS);
/*
	always @(posedge VGA_CTRL_CLK)
	begin
		if (~RES_n)
		begin
			// Clear the screen
			addr_reg <= {Coord_X[9:2],Coord_Y[9:1]} ;
			we <= 1'b0;
			data_reg <= 16'h0000;
			curReadIndex <= 9'd0;
		end
		// If we are syncing, read pixels from the circular buffer and write them to
		// the SRAM
		else if (syncing)
		begin
			addr_reg <= { pixelX[curReadIndex], pixelY[curReadIndex] };
			we <= 1'b0;
			data_reg <= { 8'b0, pixelColor[curReadIndex] };

			curReadIndex <= curReadIndex + 9'd1;
		end
		//
		// When the VGA controller needs the SRAM, retrieve pixels from SRAM
		else begin
			addr_reg <= { Coord_X[9:2], Coord_Y[9:1] } ;
			we <= 1'b1;
		end
	end
*/	

	//assign LEDR[7] = syncing;
	reg [8:0] pixelx, pixely;

	always @(/*posedge*/negedge VGA_CTRL_CLK)	// NS 08-02-17
	begin
		if (~RES_n)
		begin
			// Clear the screen
			addr_reg_biL <= {Coord_X[9:2],Coord_Y[9:2]} ;				
			//addr_reg_biH <= {Coord_X[9], Coord_X[7:2],Coord_Y[9:1]};
			weL <= 1'b0;
			//weH <= 1'b0;
			data_reg <= 8'h00;
			curReadIndex <= 9'd0;
		end
		// If we are syncing, read pixels from the circular buffer and write them to
		// the SRAM
		else if (syncing)
		begin
			//if( pixelx[curReadIndex] & 'h200)	// 9th bit is high?
			//begin
			//	addr_reg_biH <= { pixelX[curReadIndex] & 'h1ff, (pixelY[curReadIndex]) };
			//	we <= 1'b0;
			//	data_reg <= pixelColor[curReadIndex];
			//nd else begin
			
			pixelx = pixelX[curReadIndex];
			pixely = pixelY[curReadIndex];
/*
			// back to basics???		
			if( ~pixelx[8])
			begin
				addr_reg_biL <= { pixelx[7:0], pixely[8:1]};
				weL <= 1'b0;
				data_regL <= pixelColor[curReadIndex];
				ramLowEn <= 1;
				weH <= 1'b0;
			end
			else begin
				addr_reg_biH <= { pixelx[7:0], pixely[8:1]};
				weH <= 1'b0;
				data_regH <= pixelColor[curReadIndex];
				ramLowEn <= 0;
				weL <= 1'b0;
			end
*/

// dbuggubg
			if( ~pixelx[7])
			begin
			   addr_reg_biL <= { pixelx[6:0], pixely[8:0]};
				weL <= 1'b0;
				data_regL <= pixelColor[curReadIndex];
				ramLowEn <= 1;
				weH <= 1'b0;
			end
			else begin
				addr_reg_biH <= { pixelx[6:0], pixely[8:0]};
				weH <= 1'b0;
				data_regH <= pixelColor[curReadIndex];
				ramLowEn <= 0;
				weL <= 1'b0;
			end

			curReadIndex <= curReadIndex + 9'd1;
		end
		//
		// When the VGA controller needs the SRAM, retrieve pixels from SRAM
		else begin
			if( ~Coord_X[9])
			begin
				if( Coord_Y[9:1] < 8'd222)
   				addr_reg_biL <= { Coord_X[8:2], Coord_Y[9:1] } ;  
				else 
   				addr_reg_biL <= 16'd0;  

				weL <= 1'b1;
				ramLowEn <= 1;
			end
			else begin
				if( Coord_Y[9:1] < 8'd222)
					addr_reg_biH <= { Coord_X[8:2], Coord_Y[9:1] } ;	
				else
					addr_reg_biH <= 16'd0;	
				
				weH <= 1'b1;
				ramLowEn <= 0;
			end
		end
	end

		
/*  
  SEG7_LUT seg0 ( HEX0, ATARI_JOY_A_in[3:0]);
  SEG7_LUT seg1 ( HEX1, ATARI_JOY_A_in[4]);
  SEG7_LUT seg2 ( HEX2, ATARI_JOY_B_in[3:0]);
  SEG7_LUT seg3 ( HEX3, ATARI_JOY_B_in[4]);
  */
  
  SEG7_LUT seg0 ( HEX0, ATARI_ROM_Addr[3:0]);
  SEG7_LUT seg1 ( HEX1, ATARI_ROM_Addr[7:4]);
  SEG7_LUT seg2 ( HEX2, ATARI_ROM_Addr[11:8]);
  SEG7_LUT seg3 ( HEX3, { 3'd0, rom_switch });
  
  //SEG7_LUT seg3 ( HEX3, Coord_Y[15:12]);
  
`endif
		
		
//=======================================================
//  Structural coding
//=======================================================



endmodule
